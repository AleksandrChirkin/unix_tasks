# Задачи по операционным системам UNIX
Чиркин Александр, группа КБ-401

### Задача 1
Создание sparse (разреженного) файла.

При запуске *runme.sh* запускается следующая последовательность действий:
1. Сначала создается тестовый файл A размером 4\*1024\*1024 + 1 байт, в котором по смещениям- 0, 10000 и в конце файла 
записаны единицы, а в остальных местах - нули
2. При помощи скрипта *sparse_file_creator* из файла A создается sparse файл B, в котором последовательности нулевых байтов заменяются 
"дырками" посредством вызова системной функции lseek. Чтение и запись происходят поблочно, размер блока по умолчанию - 4096 байт
3. Файлы A и B сжимаются утилитой gzip в A.gz, B.gz
4. Файл B.gz распаковывается утилитой gzip в *stdout*, откуда через pipe передаются в *stdin* скрипта *sparse_file_creator*. Результат записывается в файл C
5. Файл A "прорежается" посредством скрипта *sparse_file_creator* с размером блока 100. Результат записывается в файл D
6. Командой *stat* выводятся размеры файлов A, A.gz, B, B.gz, C, D и количества занимаемых ими блоков

Скрипт *./sparse_file_creator* может быть вызван и вручную.
Для корректной работы скрипта создания sparse файла нужно вводить (позиционные) аргументы в одном из следующих видов:
1. *./sparse_file out_name* 
   1. *out_name* - имя файла вывода
   2. ввод - из *stdin*
   3. размер блока = 4096 байт
2. *./sparse_file in_name out_name*
   1. *in_name* - имя файла ввода
   2. *out_name* - имя файла вывода
   3. размер блока = 4096 байт
3. *./sparse_file out_name buf_size*
    1. *out_name* - имя файла вывода
    2. *buf_size* - размер блока
    3. ввод - из *stdin*
4. *./sparse_file in_name out_name buf_size*
    1. *in_name* - имя файла ввода
    2. *out_name* - имя файла вывода
    3. *buf_size* - размер блока

### Задача 2
Файловые блокировки на основе вспомогательных lck-файлов

При запуске *runme.sh* запускается скрипт *flock_checker*, который тестирует работу файловых блокировок в двух режимах:
1. Сначала проверяется поломка программы на снятии блокировки с файла *myfile* (путем удаления lck-файла). 

   Когда файл блокировки, созданный процессом A, удаляется, другой процесс B, ранее ожидавший его исчезновения, создает свой и пишет в него свой pid.

   После выхода из сна длиной в 1 секунду процесс A открывает lck-файл и замечает там pid процесса B.

   После чего процесс A выдает ошибку и завершается с сообщением об ошибке.

   Продолжительность работы такого режима - 2 секунды. Этого достаточно, чтобы поймать конфликт.

   По истечении двух секунд оставшийся процесс останавливается сигналом *SIGINT*, 
после чего выводится содержимое файла *myfile* - в нем будет записан порядок доступов (и, следовательно, создания lck-файлов) к *myfile*

2. Потом проверяется запуск 10 параллельных задач, которые бы блокировали *myfile* на 1 секунду
   
   При отсутствии стороннего влияния на lck-файл конфликтов не возникает.

   После 5 минут работы все задачи останавливаются сигналом *SIGINT*, при обработке которого каждая задача записывает в  *result.txt* количество успешных блокировок и свой pid

   Можно убедиться, что статистика блокировок для всех процессов примерно одинакова (обычно в диапазоне от 20 до 40), а в сумме количество всех блокировок равно 300

Скрипт *./flock_checker* имеет ряд особенностей реализации:
1. Он завершает работу как при конфликте блокировки, так и в случае ошибок ввода/вывода
2. Он имеет обработчик синала *SIGINT*, который выводит скрипт из вечного цикла и, при наличии ключа *-s*, выводит в *result.txt* статистику блокировок
3. В общий файл *myfile* происходит запись pid текущего процесса. 
Это может быть полезно для сопоставления количества упоминаний pid процесса в *myfile* с показателями в файле *result.txt*
4. Если в момент получения сигнала *SIGINT* задача имела блокировку, то она попадает в статистику