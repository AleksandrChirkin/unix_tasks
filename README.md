# Задачи по операционным системам UNIX
Чиркин Александр, группа КБ-401

## Задача 1
Создание sparse (разреженного) файла.

При запуске *runme.sh* запускается следующая последовательность действий:
1. Сначала создается тестовый файл A размером 4\*1024\*1024 + 1 байт, в котором по смещениям- 0, 10000 и в конце файла 
записаны единицы, а в остальных местах - нули
2. При помощи скрипта *sparse_file_creator* из файла A создается sparse файл B, в котором последовательности нулевых байтов заменяются 
"дырками" посредством вызова системной функции lseek. Чтение и запись происходят поблочно, размер блока по умолчанию - 4096 байт
3. Файлы A и B сжимаются утилитой gzip в A.gz, B.gz
4. Файл B.gz распаковывается утилитой gzip в *stdout*, откуда через pipe передаются в *stdin* скрипта *sparse_file_creator*. Результат записывается в файл C
5. Файл A "прорежается" посредством скрипта *sparse_file_creator* с размером блока 100. Результат записывается в файл D
6. Командой *stat* выводятся размеры файлов A, A.gz, B, B.gz, C, D и количества занимаемых ими блоков

Скрипт *./sparse_file_creator* может быть вызван и вручную.
Для корректной работы скрипта создания sparse файла нужно вводить (позиционные) аргументы в одном из следующих видов:
1. *./sparse_file out_name* 
   1. *out_name* - имя файла вывода
   2. ввод - из *stdin*
   3. размер блока = 4096 байт
2. *./sparse_file in_name out_name*
   1. *in_name* - имя файла ввода
   2. *out_name* - имя файла вывода
   3. размер блока = 4096 байт
3. *./sparse_file out_name buf_size*
    1. *out_name* - имя файла вывода
    2. *buf_size* - размер блока
    3. ввод - из *stdin*
4. *./sparse_file in_name out_name buf_size*
    1. *in_name* - имя файла ввода
    2. *out_name* - имя файла вывода
    3. *buf_size* - размер блока

## Задача 2
Файловые блокировки на основе вспомогательных lck-файлов

При запуске *runme.sh* запускается скрипт *flock_checker*, который тестирует работу файловых блокировок в двух режимах:
1. Сначала проверяется поломка программы на снятии блокировки с файла *myfile* (путем удаления lck-файла). 

   Когда файл блокировки, созданный процессом A, удаляется, другой процесс B, ранее ожидавший его исчезновения, создает свой и пишет в него свой pid.

   После выхода из сна длиной в 1 секунду процесс A открывает lck-файл и замечает там pid процесса B.

   После чего процесс A выдает ошибку и завершается с сообщением об ошибке.

   Продолжительность работы такого режима - 2 секунды. Этого достаточно, чтобы поймать конфликт.

   По истечении двух секунд оставшийся процесс останавливается сигналом *SIGINT*, 
после чего выводится содержимое файла *myfile* - в нем будет записан порядок доступов (и, следовательно, создания lck-файлов) к *myfile*

2. Потом проверяется запуск 10 параллельных задач, которые бы блокировали *myfile* на 1 секунду
   
   При отсутствии стороннего влияния на lck-файл конфликтов не возникает.

   После 5 минут работы все задачи останавливаются сигналом *SIGINT*, при обработке которого каждая задача записывает в  *result.txt* количество успешных блокировок и свой pid

   Можно убедиться, что статистика блокировок для всех процессов примерно одинакова (обычно в диапазоне от 20 до 40), а в сумме количество всех блокировок равно 300

Скрипт *./flock_checker* имеет ряд особенностей реализации:
1. Он завершает работу как при конфликте блокировки, так и в случае ошибок ввода/вывода
2. Он имеет обработчик синала *SIGINT*, который выводит скрипт из вечного цикла и, при наличии ключа *-s*, выводит в *result.txt* статистику блокировок
3. В общий файл *myfile* происходит запись pid текущего процесса. 
Это может быть полезно для сопоставления количества упоминаний pid процесса в *myfile* с показателями в файле *result.txt*
4. Если в момент получения сигнала *SIGINT* задача имела блокировку, то она попадает в статистику

## Задача 3
Аналог процесса myinit

При запуске *runme.sh* запускается демон *myinit*, которому в качестве аргумента передается файл конфигурации.
Файл конфигурации состоит из строк формата *<команда> <аргуемнты> <файл, откуда будет браться ввод> <файл, куда будет перенаправляться вывод>*
Файл конфигурации создается внутри *runme.sh*

После запуска демона происходит смена текущей директории на корневой каталог ФС, все потоки, связанные с процессом, закрываются,
управляющий терминал закрывается (вернее, он остается, но программа становится невосприимчивой к посылаемым им сигналам), открывается лог демона (по адресу */tmp/myinit.log*).
Дальше начинается построчное чтение конфигурационного файла и запуск программ в соответствии с заданными параметрами. **Все пути к исполняемым файлам должны быть абсолютными!**

При завершении запущенного таким образом процесса демон создаст аналогичный.

По сигналу SIGHUP происходит завершение всех запущенных демоном программ, повторное чтение конфигурационного файла и запуск прописанных в нем программ.

Внутри *runme.sh* происходят следующие действия:
1. Создается конфигурационный файл с описанием трех запускаемых процессов
2. Запускается myinit, который читает конфигурационный файл и запускает эти 3 процесса
3. После секунды ожидания сигналом SIGTERM останавливаем вторую задачу
4. Демон, заметив это, замещает ее аналогичной, с такими же параметрами
5. Изменяем конфигурационный файл, убрав старое содержимое и добавив одну строку
5. Еще через 7 секунд демону приходит сигнал SIGHUP
6. Демон читает конфигурационный файл с новым содержимым и запускает одну задачу
7. Демон останавливается сигналом SIGTERM, запущенный им процесс может продолжать работу

## Задача 4
Броуновский бот с клиент-серверной архитектурой

Сервер-бот внутри себя хранит текущее целочисленное состояние. На момент запуска это 0.
Клиент читает из stdin целочисленное число (не длиннее 10 символов) и отправляет их на сервер. Сервер добавляет к текущему состоянию полученную строку и возвращает новое значение состояния.
Сервер умеет буферизовывать ввод данных от клиентов и асинхронно считывать данные от многих клиентов.

При вызове *runme.sh* происходят следующие действия:
1. Параллельный запуск 100 тестовых клиентов, каждый из которых будет читать файл (один на всех) со 1000 числами (генерируются перед запуском клиента и сервера, при этом сумма всех чисел в файле равна нулю). Тестовый клиент читает из побайтово и случайно в интервале 1-255 байтов вставляет задержку в несколько долей секунды. Поскольку сумма всех чисел равна нулю, то после завершения всех клиентов внутреннее состояние сервера будет равно нулю. Это проверяется отправкой с клиента числа ноль и получения ответа ноль.
2. Провеяется, что сервер корректно работает без перезапуска при повторных выполнениях тестового скрипта; проверяется, что длительное выполнение сервера с последовательными подключениями/отключениями тестовых клиентов не приводят к существенному увеличению объёма памяти, используемой сервером, и числа занятых файловых дескрипторов. Для этого, при подключении нового клиента в лог сохраняется номер использованного для подключения файлового дескриптора и значение указателя на границу кучи sbrk(). В результат из лога выдается первая и последняя записи такого типа.
3. Время задержки делается параметром. В каждом клиенте подсчитывается суммарное время задержек и сохранить по завершению работы в файле. Запускается скрипт, который на основе логов сервера и логов клиентов показывает эффективную скорость работы сервера в зависимости от задержек и числа клиентов. Критерием эффективности считается время от первого запроса клиента до последнего минус время суммы задержек у самого “медленного” клиента. Поскольку сервер практически не выполняет вычислений, а объём передаваемых данных мал, то при корректной реализации асинхронности время работы сервера практически равно времени выполнения самого “медленного” клиента. Проводятся несколько экспериментов с 1, 2, 10 и 100 клиентами и задержками от 0 до 1 с шагом 0.2 секунды.
